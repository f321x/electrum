from dataclasses import dataclass
from abc import ABC, abstractmethod
from typing import List, Optional, Union
from electrum_ecc import ECPubkey
import hashlib
import base64

try:
    import cbor2
except ImportError:
    cbor2 = None

class CashuMelter:
    def __init__(self):


DOMAIN_SEPARATOR = b"Secp256k1_HashToCurve_Cashu_"

def hash_to_curve(message: bytes) -> ECPubkey:
    """Generates a secp256k1 point from a message.

    The point is generated by hashing the message with a domain separator and then
    iteratively trying to compute a point from the hash. An increasing uint32 counter
    (byte order little endian) is appended to the hash until a point is found that lies on the curve.

    The chance of finding a valid point is 50% for every iteration. The maximum number of iterations
    is 2**16. If no valid point is found after 2**16 iterations, a ValueError is raised (this should
    never happen in practice).

    The domain separator is b"Secp256k1_HashToCurve_Cashu_" or
    bytes.fromhex("536563703235366b315f48617368546f43757276655f43617368755f").
    """
    msg_to_hash = hashlib.sha256(DOMAIN_SEPARATOR + message).digest()
    counter = 0
    while counter < 2**16:
        _hash = hashlib.sha256(msg_to_hash + counter.to_bytes(4, "little")).digest()
        try:
            # will error if point does not lie on curve
            return ECPubkey(b"\x02" + _hash)
        except Exception:
            counter += 1
    # it should never reach this point
    raise ValueError("No valid point found")


class Proof:
    """
    Value token
    """

    id: str = ""
    amount: int = 0
    secret: str = ""  # secret or message to be blinded and signed
    Y: str = ""  # hash_to_curve(secret)
    C: str = ""  # signature on secret, unblinded by wallet
    witness: Union[None, str] = None  # witness for spending condition

    # whether this proof is reserved for sending, used for coin management in the wallet
    reserved: Union[None, bool] = False
    # unique ID of send attempt, used for grouping pending tokens in the wallet
    send_id: Union[None, str] = ""
    time_created: Union[None, str] = ""
    time_reserved: Union[None, str] = ""
    derivation_path: Union[None, str] = ""  # derivation path of the proof
    mint_id: Union[None, str] = (
        None  # holds the id of the mint operation that created this proof
    )
    melt_id: Union[None, str] = (
        None  # holds the id of the melt operation that destroyed this proof
    )

    def __init__(self, **data):
        super().__init__(**data)
        self.Y = hash_to_curve(self.secret.encode("utf-8")).get_public_key_hex()

    def __getitem__(self, key):
        return self.__getattribute__(key)

    def __setitem__(self, key, val):
        self.__setattr__(key, val)


class Token(ABC):
    @property
    @abstractmethod
    def proofs(self) -> List[Proof]: ...

    @property
    @abstractmethod
    def amount(self) -> int: ...

    @property
    @abstractmethod
    def mint(self) -> str: ...

    @property
    @abstractmethod
    def keysets(self) -> List[str]: ...

    @property
    @abstractmethod
    def memo(self) -> Optional[str]: ...

    @memo.setter
    @abstractmethod
    def memo(self, memo: Optional[str]): ...

    @property
    @abstractmethod
    def unit(self) -> str: ...

    @unit.setter
    @abstractmethod
    def unit(self, unit: str): ...

@dataclass
class TokenV4Proof:
    """
    Value token
    """

    a: int
    s: str  # secret
    c: bytes  # signature
    w: Optional[str] = None  # witness

    @classmethod
    def from_proof(cls, proof: Proof):
        return cls(
            a=proof.amount,
            s=proof.secret,
            c=bytes.fromhex(proof.C),
            w=proof.witness,
        )


class TokenV4Token:
    # keyset ID
    i: bytes
    # proofs
    p: List[TokenV4Proof]


@dataclass
class TokenV4(Token):
    # mint URL
    m: str
    # unit
    u: str
    # tokens
    t: List[TokenV4Token]
    # memo
    d: Optional[str] = None

    @property
    def mint(self) -> str:
        return self.m

    def set_mint(self, mint: str):
        self.m = mint

    @property
    def memo(self) -> Optional[str]:
        return self.d

    @memo.setter
    def memo(self, memo: Optional[str]):
        self.d = memo

    @property
    def unit(self) -> str:
        return self.u

    @unit.setter
    def unit(self, unit: str):
        self.u = unit

    @property
    def amounts(self) -> List[int]:
        return [p.a for token in self.t for p in token.p]

    @property
    def amount(self) -> int:
        return sum(self.amounts)

    @property
    def proofs(self) -> List[Proof]:
        return [
            Proof(
                id=token.i.hex(),
                amount=p.a,
                secret=p.s,
                C=p.c.hex(),
                witness=p.w,
            )
            for token in self.t
            for p in token.p
        ]

    @property
    def keysets(self) -> List[str]:
        return list({p.i.hex() for p in self.t})

    @classmethod
    def deserialize(cls, tokenv4_serialized: str) -> "TokenV4":
        """
        Ingest a serialized "cashuB<cbor_urlsafe_base64>" token and returns a TokenV4.
        """
        assert cbor2 is not None, Exception("cbor2 is required to deserialize cashu V4 tokens.")
        prefix = "cashuB"
        assert tokenv4_serialized.startswith(prefix), Exception(
            f"Token prefix not valid. Expected {prefix}."
        )
        token_base64 = tokenv4_serialized[len(prefix) :]
        # if base64 string is not a multiple of 4, pad it with "="
        token_base64 += "=" * (4 - len(token_base64) % 4)

        token = cbor2.loads(base64.urlsafe_b64decode(token_base64))
        return cls.parse_obj(token)

    @classmethod
    def parse_obj(cls, token_dict: dict):
        return cls(
            m=token_dict["m"],
            u=token_dict["u"],
            t=[TokenV4Token(**t) for t in token_dict["t"]],
            d=token_dict.get("d", None),
        )
